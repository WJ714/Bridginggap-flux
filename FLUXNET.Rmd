---
title: "Figures_FLUXNET"
output:
  html_document: default
  pdf_document: default
date: "2025-08-05"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
  echo = TRUE,
  fig.width = 11,  # Set the plot width in inches
  fig.height = 4,  # Set the plot height in inches
  warning = FALSE,  # Hide warnings
  message = FALSE   # Hide messages
)
library(data.table)
library(lubridate)
library(dplyr)
library(tidyverse)
library(Kendall)
library(ggplot2)
my_theme <- theme_light(base_size = 14) +
  theme(
    axis.text.x = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "white", color = "white"),
    plot.background = element_rect(fill = "white", color = "white")
  )

# working directory
data_dir = ("G:/My Drive/FLUX-LSM workshop/US-Syv/AMF_US-Syv_FLUXNET_SUBSET_2001-2023_4-6/")
```

# FLUXNET data

-   Variables quick start guide:
    <https://fluxnet.org/data/fluxnet2015-dataset/variables-quick-start-guide/>
-   Data variables: <https://fluxnet.org/data/aboutdata/data-variables/>
-   Full set data product:
    <https://fluxnet.org/data/fluxnet2015-dataset/fullset-data-product/>
    
    
# How to save figures using R?
We do not include code for saving figures in this tutorial. If you wish to save figures locally, you can use functions like ggsave() (for ggplot objects) or base R functions such as png(), pdf(), and others.Here are some examples:
```{r}
## ggsave
# ggsave("my_figure.png", plot = p, width = 8, height = 6, dpi = 300)

## base R function
# png("my_plot.png", width = 800, height = 600, res = 150)
# plot(x, y)
# dev.off()
```
# Read in data

## read in annual data (YY)

```{r}
filename = "AMF_US-Syv_FLUXNET_SUBSET_YY_2001-2023_4-6.csv"
setwd(data_dir); df.YY = fread(filename)
df.YY$year = as.numeric(df.YY$TIMESTAMP)
df.YY <- df.YY %>%
  mutate(across(everything(), ~na_if(. , -9999)))
```

## read in monthly data (MM)

```{r}
setwd(data_dir)
df.MM = fread(paste0("AMF_US-Syv_FLUXNET_SUBSET_MM_2001-2023_4-6.csv"))
# FLUXNET data uses "-9999" as placeholder for missing data. Replace -9999 with NA across all columns
df.MM <- df.MM %>%
  mutate(across(everything(), ~na_if(. , -9999)))

# Timestamp column of flux data is formatted as YYYYMM. We need to change it to a readable timestamp format.
class(df.MM$TIMESTAMP)
df.MM$TIMESTAMP <- ym(as.character(df.MM$TIMESTAMP))
class(df.MM$TIMESTAMP)

# Create columns of year
df.MM <- df.MM %>%
  mutate(year = year(TIMESTAMP), month = month(TIMESTAMP))
```

## read in half hourly data (HH)

Please note that the data for US-Ha1 and BR-Sa1 are provided at an
hourly scale.

```{r}
setwd(data_dir); df.HH = fread(paste0("AMF_US-Syv_FLUXNET_SUBSET_HH_2001-2023_4-6.csv")) 
# FLUXNET data uses "-9999" as placeholder for missing data. Replace -9999 with NA across all columns
df.HH <- df.HH %>%
  mutate(across(everything(), ~na_if(. , -9999)))

# Timestamp column of flux data is formatted as YYYYMMDDHHMM. We need to change it to a readable timestamp format.
class(df.HH$TIMESTAMP_END)
df.HH$TIMESTAMP_END <- ymd_hm(as.character(df.HH$TIMESTAMP_END))
class(df.HH$TIMESTAMP_END)

# Create columns of year and month
df.HH <- df.HH %>%
  mutate(year = year(TIMESTAMP_END), month = month(TIMESTAMP_END))
```

# Required task

## Task 1: annual sums of NEE

-   Variables expressing random uncertainty are identified by the suffix
    \_RANDUNC. One of two methods are used to estimate random
    uncertainty, applied hierarchically;

-   NEE-RANDUNC Method 1 (direct standard deviation method);

-   NEE-RANDUNC Method 2 (median standard deviation method) - For more
    details, please check out Pastorello et al. 2020 NEE_VUT_REF:

-   NEE_VUT_REF, using Variable Ustar Threshold (VUT) for each year,
    reference selected on the basis of the model efficiency (MEF). The
    MEF analysis is repeated for each time aggregation.

```{r}
# create upper and lower bounds
# NEE_VUT_REF_RANDUNC
df.YY$NEE_upper <- df.YY$NEE_VUT_REF + df.YY$NEE_VUT_REF_RANDUNC
df.YY$NEE_lower <- df.YY$NEE_VUT_REF - df.YY$NEE_VUT_REF_RANDUNC
ylab = expression(FCO[2] ~ "(" * mu * "mol" ~ m^{-2} ~ y^{-1} * ")")
# plot annual sums of NEE across years
ggplot(df.YY, aes(x = year)) +
  geom_ribbon(aes(ymin = NEE_lower, ymax = NEE_upper), fill = "blue", alpha = 0.4) + # random uncertainty 
  geom_line(aes(y = NEE_VUT_REF), color = "black", size = 1) +
  geom_smooth(aes(y = NEE_VUT_REF), method = "lm", color = "red", se = FALSE, linetype = "dashed") + # Trend line
  ylab(ylab) +  
  ggtitle("Annual sums of NEE") + my_theme

# The Mann-Kendall trend test is used to assess whether there is a significant monotonic trend (either increasing or decreasing) in a time series. 
MannKendall(df.YY$NEE_VUT_REF) # When P < 0.05, you can reject the null hypothesis ("no trend").

# plot qualify flags of NEE
ggplot(df.YY, aes(x = as.factor(year), y = NEE_VUT_REF_QC)) +
  geom_bar(stat = "identity", fill = "grey") +
  geom_hline(yintercept = 0.75, linetype = "dashed", color = "red") +
  labs(x = "Year", y = expression(FCO[2] ~ "(" * mu * "mol" ~ m^{-2} ~ yr^{-1} * ")"), 
       title = "Qualify flags for annual sums") +
  ylim(0, 1) +
  scale_x_discrete(breaks = df.YY$year[seq(1, nrow(df.YY), by = 2)]) +
  my_theme
```

Where to go from here:

-   Interpret the figure and include it in your group presentation.

-   Plot annual sums of LE and H (value + uncertainty).

-   Explore the qualify flags for annual sums of LE and H.

## Task 2: monthly NEE, GPP, RECO

```{r}
ylab = expression(FCO[2] ~ "(" * mu * "mol" ~ m^{-2} ~ d^{-1} * ")")
# Create date label for graphing
df.MM <- df.MM %>%
  mutate(
    date = as.Date(paste(year, month, "01", sep = "-"))
  )

# Pivot data for easier plotting
df.MM_long <- df.MM %>%
  mutate(GPP_NT_VUT_REF = -GPP_NT_VUT_REF) %>%  # make GPP negative
  select(date, year, GPP_NT_VUT_REF, RECO_NT_VUT_REF, NEE_VUT_REF) %>%
  pivot_longer(cols = c(GPP_NT_VUT_REF, RECO_NT_VUT_REF), names_to = "variable", values_to = "value")

# Create the plot
ggplot() +
  # Bar plots for GPP and RECO
  geom_col(data = df.MM_long, aes(x = date, y = value, fill = variable), position = "dodge") +
  # Line for NEE
  geom_line(data = df.MM, aes(x = date, y = NEE_VUT_REF), color = "black", size = 1) +
  scale_fill_manual(values = c("GPP_NT_VUT_REF" = "#2ca02c", "RECO_NT_VUT_REF" = "#d62728")) +
  labs(x = "Date", y = ylab, fill = "Variable", 
       title = "Daily average flux per monthly: GPP, RECO (bars) and NEE (line)") + my_theme
```

Where to go from here:

-   Interpret the figures and include them in your group presentation;

-   You can also create your own figures, e.g. monthly anomalies, or
    diurnal patterns;

## Task 3: qualify flags for half-hourly data

```{r}
df.HH <- df.HH %>% # using half-hourly data
  mutate(
    year = year(TIMESTAMP_END),
    DOY = yday(TIMESTAMP_END) + 
      (hour(TIMESTAMP_END) + minute(TIMESTAMP_END)/60 + second(TIMESTAMP_END)/3600) / 24,
    qc_label = factor(
      NEE_VUT_REF_QC,
      levels = c(0, 1, 2, 3),
      labels = c("Measured (0)", "Good (1)", "Medium (2)", "Poor (3)")
    )
  )

# calculate the percentage of each flag
qc_summary <- df.HH %>%
  group_by(year, qc_label) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(year) %>%
  mutate(
    total = sum(count),
    percent = round(100 * count / total, 1),
    label = paste0(qc_label, ": ", percent, "%")
  )


# barplot of qc_summary (% for different qualify flags) by year
qc_summary %>%
  filter(year >= 2004, year <= 2022) %>%
  ggplot(aes(x = factor(year), y = percent, fill = qc_label)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(
    name = "QC Flag",
    values = c(
      "Measured (0)" = "black",
      "Good (1)" = "green4",
      "Medium (2)" = "orange",
      "Poor (3)" = "red"
    )
  ) +
  scale_x_discrete(breaks = as.character(seq(2004, 2022, by = 2))) +
  labs(
    title = "Summary of NEE Quality Flags",
    x = "Year", y = "Percentage (%)"
  ) + my_theme

  
qc_labels <- qc_summary %>%
  group_by(year) %>%
  summarise(
    qc_text = paste(label, collapse = "\n"),
    .groups = "drop"
  )

data_with_labels <- df.HH %>%
  left_join(qc_labels, by = "year")

# looking into data for one year: plot NEE with QC flags
data_with_labels %>%
  filter(year == 2018) %>% 
  ggplot(aes(x = DOY, y = NEE_VUT_REF, color = qc_label)) +
  geom_point(alpha = 0.6, size = 1) +
  scale_color_manual(
    name = "QC Flag",
    values = c("Measured (0)" = "black",
               "Good (1)" = "green4",
               "Medium (2)" = "orange",
               "Poor (3)" = "red")
  ) +
  labs(
    title = expression("Half hourly FCO"[2]*" and quality flags for a single year"),
    x = "DOY", y = expression(FCO[2] ~ "(" * mu * "mol" ~ m^{-2} ~ s^{-1} * ")")
  ) + my_theme
```

Where to go from here:

-   Interpret the figures and include them in your group presentation;

## Task 4: monthly meteorological variables

To do: update the input data as df.MM (\@Roel)

```{r}
# Tair -----------------------------------------------------
monthly_data <- monthly_data %>%
  mutate(y_label_pos = max(Tair, na.rm = TRUE) * 1.2)

ggplot(monthly_data, aes(x = month_year)) +
  # Add continuous lines and dots for Tair
  geom_line(aes(y = Tair, color = "Tair"), size = 1) +
  geom_point(aes(y = Tair, color = "Tair"), size = 3) +
  
  # Add horizontal dashed line at 0°C
  geom_hline(yintercept = 0, linetype = "dashed", color = "black", size = 0.8) +
  
  # Add vertical dashed lines at the end of each year
  geom_vline(data = monthly_data %>% filter(month == 12), 
             aes(xintercept = as.numeric(month_year) + 15), 
             linetype = "dashed", color = "gray", size = 0.5) +
  
  # Fix year labels position
  geom_text(data = monthly_data %>% filter(month == 6), 
            aes(x = year_label_pos, label = year), 
            y = max(monthly_data$Tair, na.rm = TRUE) * 1.2, 
            color = "black", size = 5, fontface = "bold") +
  
  # Customize the plot
  labs(x = "Month", y = expression("Air Temperature (°C)"), title = "Monthly Air Temperature Trend") +
  scale_color_manual(values = c("Tair" = "orange")) +
  scale_x_date(date_labels = "%m", date_breaks = "6 month", expand = c(0, 0)) +  # Continuous months
  scale_y_continuous(
    breaks = seq(floor(min(monthly_data$Tair, na.rm = TRUE) / 10) * 10, 
                 ceiling(max(monthly_data$Tair, na.rm = TRUE) / 10) * 10, 
                 by = 4),
    limits = c(floor(min(monthly_data$Tair, na.rm = TRUE)) - 5, 
               ceiling(max(monthly_data$Tair, na.rm = TRUE)) + 5)
  ) + my_theme

# Incoming shortwave radiation -----------------------------------------------------
monthly_data <- monthly_data %>%
  mutate(y_label_pos = max(SW_IN, na.rm = TRUE) * 1)

ggplot(monthly_data, aes(x = month_year)) +
  # Add continuous lines and dots for SW_IN
  geom_line(aes(y = SW_IN, color = "SW_IN"), size = 1) +
  geom_point(aes(y = SW_IN, color = "SW_IN"), size = 3) +
  
  # Add horizontal dashed line at 0
  geom_hline(yintercept = 0, linetype = "dashed", color = "black", size = 0.8) +
  
  # Add vertical dashed lines at the end of each year
  geom_vline(data = monthly_data %>% filter(month == 12), 
             aes(xintercept = as.numeric(month_year) + 15), 
             linetype = "dashed", color = "gray", size = 0.5) +
  
  # Fix year labels position
  geom_text(data = monthly_data %>% filter(month == 6), 
            aes(x = year_label_pos, label = year), 
            y = max(monthly_data$SW_IN, na.rm = TRUE) * 1, 
            color = "black", size = 5, fontface = "bold") +
  
  # Customize the plot
  labs(x = "Month", y = expression("Incoming Shortwave Radiation (W/m²)"), 
       title = "Monthly Incoming Shortwave Trend") +
  scale_color_manual(values = c("SW_IN" = "blue")) +
  scale_x_date(date_labels = "%m", date_breaks = "6 month", expand = c(0, 0)) +  
  scale_y_continuous(
    breaks = seq(0, 
                 ceiling(max(monthly_data$SW_IN, na.rm = TRUE) / 10) * 10, 
                 by = 50),
    limits = c(0, ceiling(max(monthly_data$SW_IN, na.rm = TRUE)) + 5)
  ) + my_theme
```

# Bonus task

## Task 1: Light use efficiency

The light response curve describes how **Net Ecosystem Exchange (NEE)**
responds to incoming light (PPFD – photosynthetic photon flux density).
It is a key tool for quantifying ecosystem carbon uptake
characteristics.

-   Where**:**

    -   `PPFD`: Photosynthetic photon flux density (μmol m⁻² s⁻¹)
    -   `Amax`: Maximum photosynthetic rate at light saturation (μmol
        m⁻² s⁻¹)
    -   `alpha`: Curvature parameter describing how quickly
        photosynthesis saturates (unitless)
    -   `Rd`: Dark respiration rate (μmol m⁻² s⁻¹)

```{r}
data_filtered = df.HH[df.HH$month == 7, ] # specify the period you want like to focus on
data_filtered$PPFD = data_filtered$PPFD_IN
data_filtered$NEE = data_filtered$NEE_VUT_REF

# Function to calculate light response curve for NEE based on the Michaelis-Menten equation
light_response_NEE <- function(PPFD, Amax, alpha, Rd) {
  -((Amax * PPFD) / (alpha + PPFD) - Rd)
} # > The negative sign reflects the convention that **NEE is negative during net CO₂ uptake** (photosynthesis > respiration).

# Fit the model using non-linear least squares 
fit_NEE <- nls(NEE ~ light_response_NEE(PPFD, Amax, alpha, Rd),
               data = data_filtered,
               start = list(Amax = max(-data_filtered$NEE, na.rm = TRUE),
                            alpha = 200, Rd = 2))

# Extract model parameter estimates
params <- coef(fit_NEE)
Amax_est <- round(params["Amax"], 2)
alpha_est <- round(params["alpha"], 2)
Rd_est <- round(params["Rd"], 2)

# Compute NEE at 2000 μmol m⁻² s⁻¹ light intensity
A2000 = Amax_est * 2000/(alpha_est + 2000)

# Generate predicted values from the fitted model
data_filtered$NEE_pred <- predict(fit_NEE, newdata = data_filtered)
ggplot(data_filtered, aes(x = PPFD, y = NEE))  +
  geom_point() +
  geom_line(aes(y = NEE_pred), color = "red", size = 1.2) +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey", size = 1) +  
  geom_vline(xintercept = 1800, linetype = "dashed", color = "grey", size = 1) +
  labs(x = expression(PPFD ~ "(" * mu * "mol" ~ m^{-2} ~ s^{-1} * ")"), 
       y = expression(FCO[2] ~ "(" * mu * "mol" ~ m^{-2} ~ s^{-1} * ")")) +
  my_theme

# Function to compute A2000  
fit_light_response_NEE <- function(data) {
  # Skip if not enough data
  if (nrow(data) < 10 || all(is.na(data$NEE))) return(NULL)

  # Michaelis-Menten light response model
  light_response_NEE <- function(PPFD, Amax, alpha, Rd) {
    -((Amax * PPFD) / (alpha + PPFD) - Rd)
  }

  # Try fitting the model, catch failures
  fit_result <- tryCatch({
    nls(NEE ~ light_response_NEE(PPFD, Amax, alpha, Rd),
        data = data,
        start = list(
          Amax = max(-data$NEE, na.rm = TRUE),  # guess based on data
          alpha = 200,
          Rd = 2
        ),
        control = nls.control(maxiter = 100, warnOnly = TRUE)
    )
  }, error = function(e) {
    message("Model failed for one year: ", e$message)
    return(NULL)
  })

  # If fitting was successful, extract A2000
  if (!is.null(fit_result)) {
    params <- coef(fit_result)
    Amax <- params["Amax"]
    alpha <- params["alpha"]
    A2000 <- Amax * 2000 / (alpha + 2000)
    return(data.frame(Amax = Amax, alpha = alpha, Rd = params["Rd"], A2000 = A2000))
  } else {
    return(NULL)
  }
}

# compute A2000 for each year
data_by_year <- split(data_filtered, data_filtered$year)
results_by_year <- lapply(data_by_year, fit_light_response_NEE)
names(results_by_year) <- names(data_by_year)
results_df <- bind_rows(results_by_year, .id = "Year")

ggplot(results_df, aes(x = as.numeric(Year), y = A2000)) +
  geom_line() +
  geom_point() +
  labs(title = "A2000 over Years", x = "Year", 
       y = expression(A2000 ~ "(" * mu * "mol" ~ m^{-2} ~ s^{-1} * ")")) +
  ylim(0,50) + my_theme
```

Where to go from here:

-   Interpret the figures and include them in your group presentation.

-   Explore the seasonal pattern of A2000.

-   Group discussion: What parameters used in land surface models relate
    to light use and photosynthesis?

## Task 2: Ecosystem water budget

-   ET = Evapotranspiration (the sum of evaporation from soil +
    transpiration from plants)

-    P = Precipitation (all water input from rain/snow).

### aggregate to monthly sums

```{r}
lambda <- 2.45e6  # Latent heat of vaporization (J/kg)
sec_per_30min <- 30*60  # Seconds in 30 minutes
molarMass <- 12.011 # molar mass of carbon (C) in grams per mole (g/mol)

df.HH <- df.HH %>%
  mutate(ET = (LE_F_MDS / lambda) * sec_per_30min) # convert unit from  W m-2 to mm

# Conversion factor for converting unit from µmol CO2 mol-1 to g C m-2 month-1
conversion_factor_C <- (molarMass * 10^(-3)) * 1800 / 1000  # molarMass * (sec per 30 min) / (mg to g)

# Summarize the data by year and month for NEE, GPP, RECO, and additional variables
## For NEE, GPP, and Reco, converting unit from µmol CO2 mol-1 to g C m-2 month-1
monthly_data <- df.HH %>%
  group_by(year, month) %>%
  summarise(
    NEE = sum(NEE_VUT_REF * conversion_factor_C, na.rm = TRUE), # unit: g C m-2 month-1
    GPP = -sum(GPP_DT_VUT_REF * conversion_factor_C, na.rm = TRUE), # unit: g C m-2 month-1
    RECO = sum(RECO_DT_VUT_REF * conversion_factor_C, na.rm = TRUE), # unit: g C m-2 month-1
    P = sum(P_F, na.rm = TRUE), # unit: mm
    ET = sum(ET, na.rm = TRUE), # unit: mm
    # n() * 0.5 gives the number of hours covered by the data
    NETRAD = sum(NETRAD, na.rm = TRUE) / (n() * 0.5),  # Convert to W/m²
    LE = sum(LE_F_MDS, na.rm = TRUE) / (n() * 0.5),  # Convert to W/m²
    H = sum(H_F_MDS, na.rm = TRUE) / (n() * 0.5),  # Convert to W/m²
    SW_IN = sum(SW_IN_F, na.rm = TRUE) / (n() * 0.5),  # Convert to W/m²
    Tair = median(TA_F, na.rm = TRUE),  # Monthly median of air temperature
    .groups = "drop"
  ) %>%
  mutate(
    month_year = as.Date(paste(year, month, 1, sep = "-")),
    year_label_pos = as.Date(paste(year, "07", "01", sep = "-"))
  ) 
```

### plot the data
```{r}
# Add ET/P ratio to monthly_data
monthly_data <- monthly_data %>%
  mutate(ET_P_ratio = ET / P)

# Add GPP/ET ratio to monthly_data for WUE
monthly_data <- monthly_data %>%
  # compute WUE: mass-based Water Use Efficiency: grams of carbon fixed per kilogram of water lost
  mutate(WUE = -(GPP)/ET) # WUE unit:  g C kg -1 H2O

# plot: P and ET
ggplot(monthly_data, aes(x = month_year)) +
  geom_bar(aes(y = P, fill = "P"), stat = "identity", position = "dodge", alpha = 0.7) +
  geom_line(aes(y = ET, color = "ET"), size = 1) +
  geom_vline(data = monthly_data %>% filter(month == 12), 
             aes(xintercept = as.numeric(month_year) + 15), 
             linetype = "dashed", color = "black", size = 0.5) +
  geom_text(data = monthly_data %>% filter(month == 6),
            aes(x = year_label_pos,
                y = max(ET, P, na.rm = TRUE) * 0.9,  # Adjust label position based on max value of y
                label = year),
            color = "black", size = 3) +
  labs(x = "Month", y = expression("mm of water"), title = "Monthly ET and P Trends") +
  scale_fill_manual(values = c("P" = "gray")) +  # P (bars)
  scale_color_manual(values = c("ET" = "#F8766D")) +  # ET (line)
  scale_x_date(date_labels = "%m", date_breaks = "6 month", expand = c(0, 0)) +  
  scale_y_continuous(
    breaks = seq(0, ceiling(max(monthly_data$ET, monthly_data$P, na.rm = TRUE) + 5), by = 50),
    limits = c(0, ceiling(max(monthly_data$ET, monthly_data$P, na.rm = TRUE) + 5))
  )  + my_theme

# plot: water use efficiency
ylab = ylab(expression(WUE ~ "(" * g~C~kg^{-1}~H[2]*O * ")"))

ggplot(monthly_data, aes(x = month_year, y = WUE)) +
  geom_bar(stat = "identity", fill = "#619CFF", alpha = 0.8) +
  labs(x = "Month", y = ylab, title = "Water-use efficiency (GPP/ET)") +
  geom_vline(data = monthly_data %>% filter(month == 12), 
             aes(xintercept = as.numeric(month_year) + 15), 
             linetype = "dashed", color = "black", size = 0.5) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "black", size = 0.8) +
  geom_text(data = monthly_data %>% filter(month == 6), 
            aes(x = year_label_pos, 
                y = 18,  # Adjust label position based on max value of y
                label = year), color = "black", size = 3) +
  scale_x_date(date_labels = "%m", date_breaks = "6 month", expand = c(0, 0)) +
  scale_y_continuous(
    breaks = seq(0, ceiling(max(monthly_data$WUE, na.rm = TRUE) + 1), by = 10),
    limits = c(0, ceiling(max(monthly_data$WUE, na.rm = TRUE) + 0.5))
  ) + my_theme

```

Where to go from here: - Interpret the figure and include it in your
group presentation.

## Task 3: Energy balance closure

The **energy balance closure equation** is used to evaluate how well the
measured energy components at an eddy covariance site balance. The
standard form is:

$$
R_n - G = H + LE
$$

Where:

-   $R_n$: Net radiation *(W m⁻²)*
-   $G$: Ground heat flux *(W m⁻²)*
-   $H$: Sensible heat flux *(W m⁻²)*
-   $LE$: Latent heat flux *(W m⁻²)*

A commonly used metric is the **closure ratio**, defined as:

$$
\text{Closure Ratio} = \frac{H + LE}{R_n - G}
$$

This ratio should ideally be close to **1**.\
Values significantly below 1 suggest underestimation of turbulent fluxes
($H + LE$), possibly due to:

-   Measurement errors
-   Missing energy storage terms
-   Unaccounted biophysical or soil processes

```{r}
xlab  = expression(Rn+G~'('*W~m^{-2}*')')
ylab = expression(H+LE~'('*W~m^{-2}*')')

df.plot = data.frame(v1 = df.HH$NETRAD - df.HH$G_F_MDS, 
                v2 = df.HH$H_F_MDS + df.HH$LE_F_MDS,
                year = df.HH$year)

ggscatter(
  data = df.plot,
  x = "v1",  y = "v2",      
  color = "grey",
  add = "reg.line",
  add.params = list(color = "black", size = 1),  # regression line
  conf.int = TRUE, cor.coef = TRUE,
  cor.coeff.args = list(size = 6),
  title = "Energy balance closure"
) +
stat_regline_equation(
  aes(label = ..eq.label..),
  label.x = -250, label.y = 600, # adjust the position if needed
  size = 6
) + 
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed", size = 1) +
  xlab(xlab) + ylab(ylab) +
  xlim(-250, 800) + ylim(-250,800) # adjust the limits if needed

# Calculate closure ratio
df.plot <- df.plot %>%
  mutate(closure_ratio = v2 / v1)
df.yearly <- df.plot %>%
  group_by(year) %>%
  summarize(mean_ratio = mean(closure_ratio, na.rm = TRUE))
# plotu closure ratio by year
ggplot(df.yearly, aes(x = year, y = mean_ratio)) +
  geom_col(fill = "grey") +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +
  labs(
    title = "Energy Balance Closure Ratio by Year",
    x = "Year", y = "Closure Ratio (unitless)"
  ) + my_theme
```

Where to go from here:

-   Interpret the figures and include them in your group presentation.

# References

-   Pastorello, Gilberto, et al. "The FLUXNET2015 dataset and the
    ONEFlux processing pipeline for eddy covariance data." Scientific
    data 7.1 (2020): 225.
-   
